#!/usr/bin/python3
import tornado.ioloop
import subprocess
import json
import fcntl
import os
import sys
import datetime
import math

audio_sink = 'analog'

# Be unbuffered
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 1)

def debug(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

io_loop = tornado.ioloop.IOLoop.instance()

monitor_order = None
def load_monitor_order():
    monitors = subprocess.check_output(['monitor-order']).decode().strip().split(',')

    global monitor_order
    monitor_order = {
        name: index
        for (index, name) in enumerate(monitors)
    }
load_monitor_order()

class LineBuffer(object):
    def __init__(self):
        self.buffer = b''
    
    def read_lines(self, input):
        while b'\n' in input:
            before, after = input.split(b'\n', 1)
            yield self.buffer + before

            self.buffer = b''
            input = after
        self.buffer += input
    

class ProcessReactor(object):
    def __init__(self, *args, **kwargs):
        kwargs['stdout'] = subprocess.PIPE
        self.process = subprocess.Popen(*args, **kwargs)

        self.fd = self.process.stdout.fileno()
        fl = fcntl.fcntl(self.fd, fcntl.F_GETFL)
        fcntl.fcntl(self.fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

        io_loop.add_handler(self.process.stdout, 
                            self.can_read, io_loop.READ)
        self.line_buffer = LineBuffer()

    def can_read(self, fd, events):
        data = self.process.stdout.read(1024)
        if len(data) > 0:
            self.on_data(data)
        else:
            print('Lost connection to subprocess')
            sys.exit(1)

    def on_data(self, data):
        for line in self.line_buffer.read_lines(data):
            self.on_line(line.decode('UTF-8'))
    
    def on_line(self, line):
        pass
    

class XTitleReactor(ProcessReactor):
    def __init__(self):
        super().__init__(['xtitle', '-s'])
    
    def on_line(self, line):
        bar.window_title = line
        bar.update()


class VolumeReactor(ProcessReactor):
    def __init__(self):
        super().__init__(['pulse-volume-monitor', '--json',
                          '--desired-sink', audio_sink])
    
    def on_line(self, line):
        bar.volume = json.loads(line)
        bar.update()


class BspcReactor(ProcessReactor):
    def __init__(self):
        super().__init__(['bspc', 'subscribe'])
    
    def on_line(self, line):
        line = line[1:] #remove leading 'W'
        fields = line.split(':')

        monitors = []
        monitor = None

        for field in fields:
            label, value = field[0], field[1:]
            if label in ('M', 'm'):
                if monitor is not None:
                    monitors.append(monitor)

                monitor = {
                    'name': value, 
                    'active': label == 'M', 
                    'desktops': [], 
                    'layout': 'unknown', 
                }
            elif label in ('O', 'F', 'U', 'o', 'f', 'u'):
                # o -> ocuppied
                # f -> free
                # u -> urgent
                # UPPERCASE -> focused
                desktop = {
                    'name': value, 
                    'ocuppied': (label.lower() != 'f'), 
                    'focused': label.isupper(), 
                    'status': label.lower()
                }
                monitor['desktops'].append(desktop)
            elif label == 'L':
                monitor['layout'] = value
        monitors.append(monitor)

        bar.monitors = monitors
        bar.update()

class Bar(object):
    def __init__(self):
        self.window_title = ''
        self.time = ''
        self.monitors = None
        self.volume = None
        self.last_update = None
        self.apps_running = None

    def render_desktop(self, monitor, imonitor, desktop, idesktop):
        idesktop_all_screens = idesktop + imonitor * 4
        # The link switches to the clicked desktop
        link = '%{{A:bspc desktop --focus ^{idesktop}:}}{content}%{{A}}'
        icons = self.apps_running[monitor['name']][desktop['name']]
        if len(icons) > 0:
            icons = ' ' + ' '.join(icons) + ' '
        else:
            icons = ''

        content = '  %s %s ' % (desktop['name'], icons)


        background_color = '-'
        line_color = '-'

        if desktop['ocuppied']:
            background_color = '#4F6F4F' # green

        if desktop['status'] == 'u': # urgent
            # Use a red bar if the desktop has an urgent window
            line_color = '#FF2020'
            background_color = '#FF6F6F'
        elif desktop['focused']:
            # Use a green bar if the desktop is focused
            line_color = '#00FF00'


        # Wrap content with background
        content = '%{{B{background}}}{0}%{{B-}}'.format(content, 
                     background=background_color)

        # Wrap content with underline
        if line_color != '-':
            content = '%{{U{line}}}%{{+u}}{0}%{{-u}}'.format(content, 
                         line=line_color)

        # Wrap content with link
        return link.format(idesktop=idesktop_all_screens, 
                           content=content)

    def render_desktops(self, monitor, imonitor):
        return '  '.join(
            self.render_desktop(monitor, imonitor, desktop, idesktop)
            for idesktop, desktop in enumerate(monitor['desktops'], 1)
        )

    def render_layout(self, monitor):
        return '%{F#FFCE88}' + monitor['layout'] + '%{F-}'
    

    def render_monitor(self, monitor, imonitor):
        out = '%{{l}}{margin}{desktops}' \
               '%{{c}}{title}' \
               '%{{r}}{layout}   {volume}  {time}{margin}'.format(**{
            'margin': ' ' * 4, 
            'desktops': self.render_desktops(monitor, imonitor), 
            'title': self.window_title, 
            'volume': self.render_volume(),
            'time': self.time, 
            'layout': self.render_layout(monitor), 
        })
        return out

    def render_volume(self):
        if self.volume is None:
            out = ""
        else:
            if self.volume['muted']:
                speaker_icon = '\uf026'
            else:
                speaker_icon = '\uf028'

            number_bars = 16
            volume = min(self.volume['max_volume'], 1)

            if not self.volume['muted']:
                filled_bars = round(number_bars * volume) 
            else:
                filled_bars = 0
            empty_bars = number_bars - filled_bars

            filled_bar_icon = '%{F#FFFFFF}\uf402%{F-}'
            empty_bar_icon = '%{F#7F7F7F}\uf402%{F-}'#'\u25af'

            bars = (filled_bar_icon * filled_bars) + (empty_bar_icon * empty_bars)

            out = "%s %s" % (speaker_icon, bars)
        return out
    

    def bar_monitor_number(self, imonitor):
        # The monitor numbers used by bar do not always coincide with bspwm
        # This only works for my desktop computer
        return 1 if imonitor == 0 else 0

    def render(self):
        if self.monitors is None:
            return None # skip for now

        self.apps_running = get_running_apps()

        if len(self.monitors) > 0:
            buf = ''

            for imonitor, monitor in enumerate(self.monitors):
                # ignore removed monitors (those that were connected and
                # therefore bspwm remembers them but they are no longer used)
                if monitor['name'] in monitor_order.keys():
                    buf += '%{{S{0}}}{1}'.format(
                        monitor_order[monitor['name']],
                        self.render_monitor(monitor, imonitor))
            return buf

    
    def update(self):
        new_update = self.render()
        if new_update is not None and new_update != self.last_update:
            print(new_update)
            sys.stdout.flush()
            self.last_update = new_update
    
_class_map = {
    ("chrome",
     "google-chrome",
     "google-chrome-stable", 
     "google-chrome-unstable", 
     "chromium"): 
        "\uf268", 

    "firefox": "\uf269", 

    # yeah, I use all of those
    # Check the classes with xprop |grep WM_CLASS
    ("jetbrains-pychar", 
     "jetbrains-webstorm", 
     "jetbrains-idea", 
     "jetbrains-idea-c", 
     "jetbrains-clion", 
     "jetbrains-studi", 
     "jetbrains-phpstorm", 
     "emacs", 
     "code", 
     "qtcreator"): 
        "\uf121", 

    "gvim": "\uf27d", 
    "teamspeak 3": "\uf0c0", 
    "steam": "\uf1b6", 
    "": "\uf1bc", #spotify
    ("dolphin", "dolphin4"): "\uf07c", 
    "thunderbird": "\uf003", 
    "skype": "\uf17e", 
    "gajim": "\uf075", 
    "clementine": "\uf001", 
    ("gnome-terminal", 
     "konsole", 
     "xterm", 
     "termite", 
     "terminology", 
     "urxvt"): 
        "\uf120", 
    "okular": "\uf02d", 
    "gimp": "\uf1fc", 
    "inkscape": "\uf040", 
}
def expand_to_list(item):
    if isinstance(item, tuple):
        return item
    else:
        return (item, )
class_map = {}
for keys, value in _class_map.items():
    keys = expand_to_list(keys)
    for key in keys:
        assert key == "" or key.islower()
        class_map[key] = value

def get_running_apps():
    wm_state = subprocess.check_output(['bspc', 'wm', '--dump-state']).decode()
    wm_state = json.loads(wm_state)

    def process_monitor(monitor):
        return {
            desktop["name"]: process_desktop(desktop)
            for desktop in monitor["desktops"]
        }

    def process_desktop(desktop):
        return process_node(desktop['root'])

    def process_node(node):
        if node is None:
            return []
        else:
            if node['client']:
                this_node_values = process_class(node['client']['className'])
            else:
                this_node_values = []
            return this_node_values + \
                    process_node(node['firstChild']) + \
                    process_node(node['secondChild'])

    def process_class(class_name):
        icon = class_map.get(class_name.lower())
        if icon:
            return [icon]
        else:
            return []

    return {
        monitor['name']: process_monitor(monitor)
        for monitor in wm_state['monitors']
    }

def update_time():
    now = datetime.datetime.now()
    time = now.strftime('%{U#00FF00}%{+u}%Y-%m-%d   %H:%M%{-u}')
    bar.time = time
    bar.update()

    seconds_to_next_min = 60 - now.second
    io_loop.call_later(seconds_to_next_min, update_time)

bar = Bar()
xtitle = XTitleReactor()
volume = VolumeReactor()
bspc = BspcReactor()
update_time()

io_loop.start()
